Tiene lo de main antes de grandes cambios que me dice gemini.

import asyncio
import aiohttp
import pymelcloud
import os
import json
import traceback
import time
from datetime import datetime
from zoneinfo import ZoneInfo

# --- CONFIGURACI√ìN ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
STATE_FILE = os.path.join(BASE_DIR, "estado_melcloud.json")
LAST_ACTION_FILE = os.path.join(BASE_DIR, "ultima_accion.json")
TZ_SPAIN = ZoneInfo("Europe/Madrid")

# PAR√ÅMETROS DE CONTROL
DURACION_BLOQUEO_MANUAL = 3600
UMBRAL_SEGURIDAD_FRIO = 5.0
UMBRAL_BUEN_TIEMPO_INVIERNO = 18.0
UMBRAL_CORTE_VERANO = 22.0 

# CONFIGURACI√ìN DE TEMPERATURAS POR HABITACI√ìN
TEMP_OBJETIVOS = {
    "Sal√≥n": 23.0,
    "Dormitorio": 23.0,
    "Jimena": 23.0,
    "Elisa": 23.0
}
DEFAULT_TEMP_AUTO = 23.0 # Fallback por si hay un dispositivo con nombre desconocido

# CREDENCIALES
EMAIL = os.getenv("EMAIL")
PASSWORD = os.getenv("PASSWORD")
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")
LAT, LON = 41.6596, -4.7454

def log(msg):
    ts = datetime.now(TZ_SPAIN).strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{ts}] {msg}", flush=True)

def load_json(path, default):
    if not os.path.exists(path):
        log(f"üìÇ DEBUG: Archivo {os.path.basename(path)} no existe, creando nuevo.")
        return default.copy()
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        log(f"‚ùå ERROR: Fallo leyendo {path}: {e}")
        return default.copy()

def save_json(path, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        log(f"‚ùå ERROR: Fallo guardando {path}: {e}")

async def enviar_telegram(session, msg, temp=None):
    if temp is not None:
        msg = f"{msg}\n\nüå°Ô∏è <b>Temp. exterior:</b> {temp}¬∞C"
    
    # Limpieza para el log de consola (evitar error de f-string con backslash)
    msg_log = msg.replace('\n', ' ')
    log(f"üì® TELEGRAM INTENTO DE ENV√çO: {msg_log}")
    
    if not BOT_TOKEN or not CHAT_ID:
        log("‚ö†Ô∏è TELEGRAM: No configurado (Falta Token o Chat ID)")
        return
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        payload = {"chat_id": CHAT_ID, "text": msg, "parse_mode": "HTML"}
        async with session.post(url, json=payload) as resp:
            if resp.status != 200:
                log(f"‚ö†Ô∏è TELEGRAM ERROR {resp.status}: {await resp.text()}")
            else:
                log("‚úÖ TELEGRAM: Enviado correctamente.")
    except Exception as e:
        log(f"‚ö†Ô∏è TELEGRAM EXCEPTION: {e}")

async def check_telegram_commands(session, registro, estados_previos, temp_ext, devices, es_invierno, en_horario):
    if not BOT_TOKEN:
        return
    last_id = registro.get("last_telegram_update_id", 0)
    log(f"ü§ñ TELEGRAM CHECK: Buscando actualizaciones desde ID {last_id}...")
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/getUpdates"
        params = {"offset": last_id + 1, "timeout": 5}
        async with session.get(url, params=params) as resp:
            if resp.status == 200:
                data = await resp.json()
                results = data.get("result", [])
                if not results:
                    log("ü§ñ TELEGRAM: No hay mensajes nuevos.")
                for result in results:
                    update_id = result["update_id"]
                    registro["last_telegram_update_id"] = update_id
                    msg_text = result.get("message", {}).get("text", "").lower()
                    log(f"üì© MENSAJE RECIBIDO: '{msg_text}'")
                    
                    if "/reset" in msg_text:
                        log("üö® COMANDO /reset DETECTADO: Limpiando bloqueos")
                        for dev_name in estados_previos:
                            estados_previos[dev_name]["bloqueo_hasta"] = 0
                        await enviar_telegram(session, "‚úÖ <b>Comando recibido:</b> Bloqueos manuales reseteados.", temp_ext)
                    
                    if "/stop" in msg_text:
                        registro["stop_mode"] = True
                        log("üõë COMANDO /stop DETECTADO: Desactivando encendido autom√°tico.")
                        await enviar_telegram(session, "üõë <b>Modo STOP activado:</b> Las m√°quinas no se encender√°n autom√°ticamente.", temp_ext)

                    if "/start" in msg_text:
                        registro["stop_mode"] = False
                        log("‚ñ∂Ô∏è COMANDO /start DETECTADO: Reanudando control autom√°tico.")
                        await enviar_telegram(session, "‚ñ∂Ô∏è <b>Modo START activado:</b> Control autom√°tico reanudado.", temp_ext)

                    if "/info" in msg_text or "\\info" in msg_text:
                        log("üìä COMANDO /info DETECTADO: Generando reporte")
                        status_stop = "üõë ACTIVO (Parado)" if registro.get("stop_mode") else "üü¢ INACTIVO (Auto)"
                        txt = f"üìä <b>ESTADO DEL SISTEMA</b>\n"
                        txt += f"üìÖ <b>Temporada:</b> {'Invierno' if es_invierno else 'Verano'}\n"
                        txt += f"üïí <b>Horario:</b> {'DENTRO' if en_horario else 'FUERA'}\n"
                        txt += f"üö´ <b>Modo STOP:</b> {status_stop}\n\n"
                        txt += "<b>Dispositivos:</b>\n"
                        for d in devices:
                            status = "üü¢ ON" if d.power else "üî¥ OFF"
                            txt += f"‚Ä¢ {d.name}: {status} ({d.target_temperature}¬∞C)\n"
                        await enviar_telegram(session, txt, temp_ext)
    except Exception as e:
        log(f"‚ö†Ô∏è Error chequeando Telegram: {e}")

async def main():
    print("\n")
    log("üîä === INICIO CICLO V7.0 (TEMPERATURAS POR ZONA) ===")
    async with aiohttp.ClientSession() as session:
        registro = load_json(LAST_ACTION_FILE, {})
        estados_previos = load_json(STATE_FILE, {})
        
        if "last_telegram_update_id" not in registro:
            registro["last_telegram_update_id"] = 0
        if "stop_mode" not in registro:
            registro["stop_mode"] = False

        # --- TIEMPO ---
        ahora = datetime.now(TZ_SPAIN)
        ahora_ts = time.time()
        minutos = ahora.hour * 60 + ahora.minute
        es_finde = ahora.weekday() >= 0
        es_invierno = ahora.month >= 10 or ahora.month <= 5
        en_horario = ((not es_finde and (390 <= minutos < 600 or 840 <= minutos < 1080)) or (es_finde and 390 <= minutos < 1380))

        log("--- DATOS TEMPORALES ---")
        log(f"üìÖ Fecha: {ahora.strftime('%A %d/%m/%Y %H:%M')}")
        log(f"‚õÑ ¬øEs Invierno?: {'SI' if es_invierno else 'NO (Es Verano)'}")
        log(f"üïí ¬øDentro de horario?: {'SI' if en_horario else 'NO'}")
        log(f"üö´ ¬øModo STOP activo?: {'SI' if registro['stop_mode'] else 'NO'}")

        # --- TEMPERATURA EXTERIOR (OPEN-METEO) ---
        temp_ext = None
        log("--- DATOS METEOROL√ìGICOS ---")
        try:
            url = f"https://api.open-meteo.com/v1/forecast?latitude={LAT}&longitude={LON}&current_weather=true"
            async with session.get(url) as r:
                data = await r.json()
                temp_ext = float(data["current_weather"]["temperature"])
                log(f"üì° Open-Meteo √âXITO: {temp_ext}¬∞C")
        except Exception as e:
            log(f"‚ùå ERROR CLIMA: {e}")
            return

        # --- MELCLOUD ---
        log("--- DISPOSITIVOS MELCLOUD ---")
        token = await pymelcloud.login(EMAIL, PASSWORD, session)
        devices = (await pymelcloud.get_devices(token, session)).get("ata", [])
        await asyncio.gather(*(d.update() for d in devices))

        await check_telegram_commands(session, registro, estados_previos, temp_ext, devices, es_invierno, en_horario)

        for dev in devices:
            # Determinar temperatura objetivo para este dispositivo
            temp_objetivo_actual = TEMP_OBJETIVOS.get(dev.name, DEFAULT_TEMP_AUTO)
            
            accion_manual = None
            print("-" * 40)
            log(f"üí† DISPOSITIVO: {dev.name}")
            log(f"    üéØ Target Configurado Auto: {temp_objetivo_actual}¬∞C")
            log(f"    üìä Estado Actual: Power={dev.power} | Target={dev.target_temperature}¬∞C")

            mem = estados_previos.get(dev.name, {"power": dev.power, "target_temperature": dev.target_temperature, "bloqueo_hasta": 0})
            log(f"    üíæ Estado Memoria: Power={mem['power']} | Target={mem['target_temperature']} | BloqueoHasta={mem['bloqueo_hasta']}")

            if (mem["power"] != dev.power or mem["target_temperature"] != dev.target_temperature):
                if ahora_ts > mem["bloqueo_hasta"]:
                    log("    ‚úã CAMBIO MANUAL DETECTADO: Activando bloqueo.")
                    accion_manual = f"‚úã <b>ACCION MANUAL:</b> {dev.name}: Power={dev.power} | Target={dev.target_temperature}¬∞C"
                    mem["bloqueo_hasta"] = ahora_ts + DURACION_BLOQUEO_MANUAL
            
            mem["power"] = dev.power
            mem["target_temperature"] = dev.target_temperature
            estados_previos[dev.name] = mem

            if accion_manual:
                await enviar_telegram(session, accion_manual, temp_ext)

            if mem["bloqueo_hasta"] > ahora_ts:
                log(f"    ‚è≥ EN BLOQUEO MANUAL: Quedan {int((mem['bloqueo_hasta']-ahora_ts)/60)} min. SALTANDO.")
                continue

            log("    üß† --- MOTOR DE DECISI√ìN ---")
            accion_tomada = None

            # 1. SEGURIDAD EXTREMA
            if temp_ext < UMBRAL_SEGURIDAD_FRIO:
                log(f"      ‚ö†Ô∏è REGLA SEGURIDAD: {temp_ext} < {UMBRAL_SEGURIDAD_FRIO}")
                if dev.power:
                    await dev.set({"power": False})
                    mem["power"] = False
                    accion_tomada = f"‚ùÑÔ∏è <b>SEGURIDAD FRIO:</b> Apagado {dev.name}"
            
            # 2. REGLA VERANO FRESCO (Prioridad sobre STOP)
            elif (not es_invierno) and (temp_ext < UMBRAL_CORTE_VERANO):
                log(f"      ‚òÄÔ∏è VERANO Y FRESCO: {temp_ext} < {UMBRAL_CORTE_VERANO} (Incluso en STOP)")
                if dev.power:
                    await dev.set({"power": False})
                    mem["power"] = False
                    accion_tomada = f"‚òÄÔ∏è <b>FRIO VERANO:</b> Apagado {dev.name}"

            # 3. MODO STOP TELEGRAM
            elif registro.get("stop_mode"):
                log("      üõë MODO STOP ACTIVO: Se ignoran l√≥gicas de encendido.")
                if dev.power:
                    await dev.set({"power": False})
                    mem["power"] = False
                    accion_tomada = f"‚ùÑÔ∏è <b>COMANDO STOP:</b> Apagado {dev.name}"

            # 4. L√ìGICA NORMAL
            else:
                if es_invierno:
                    if not en_horario:
                        log(f"      üïí FUERA DE HORARIO")
                        if dev.power:
                            await dev.set({"power": False})
                            mem["power"] = False
                            accion_tomada = f"üïí <b>HORARIO:</b> Apagado {dev.name}"
                    elif en_horario and temp_ext <= UMBRAL_BUEN_TIEMPO_INVIERNO:
                        log(f"      üî• CONDICIONES OK: En horario y {temp_ext} <= {UMBRAL_BUEN_TIEMPO_INVIERNO}")
                        if not dev.power or dev.target_temperature != temp_objetivo_actual:
                            await dev.set({"power": True, "target_temperature": temp_objetivo_actual, "operation_mode": "heat"})
                            mem["power"] = True
                            mem["target_temperature"] = temp_objetivo_actual
                            accion_tomada = f"üî• <b>AUTO:</b> Encendido {dev.name} a {temp_objetivo_actual}¬∞C"

            if accion_tomada:
                await enviar_telegram(session, accion_tomada, temp_ext)

        save_json(STATE_FILE, estados_previos)
        save_json(LAST_ACTION_FILE, registro)
    log("üèÅ === FIN CICLO V7.0 ===")

if __name__ == "__main__":
    async def run_safe():
        try:
            await main()
        except Exception:
            log(f"‚ùå FATAL ERROR:\n{traceback.format_exc()}")
    asyncio.run(run_safe())
